<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Heros list | Rivengard</title>
<style>
	#el_form {
		position: fixed;
		bottom: 0;
		left: 0;
		right: 0;
		z-index: 2;
		background-color: #0009;
		backdrop-filter: blur(3px);
		padding: 1em;

		.filter-toggle {
			text-align: center;
			outline: none;
		}
	}

	#el_reset {
		position: absolute;
		top: 1em;
		left: 1.5em;
	}

	#el_filters {
		line-height: 1;
		font-size: smaller;
		flex-wrap: wrap;
		margin-top: 1em;
		gap: 1em;
		display: grid;
		grid-template-columns: repeat(8, 1fr);

		@media (max-width: 1200px) {
			grid-template-columns: repeat(4, 1fr);
		}
		@media (max-width: 660px) {
			grid-template-columns: repeat(2, 1fr);
			font-size: small;
		}

		dd {
			margin: 0 0 .25em;
		}

		input[type="checkbox"] {
			font-size: smaller;
			width: 1em;
			height: 1em;
		}

		fieldset {
			position: relative;
			margin: 0;

			/* &:last-of-type details > div {
				columns: 2;
			} */

			fieldset + fieldset {
				margin-top: .5em;
			}
		}

		legend {
			text-transform: capitalize;
		}

		summary {
			position: absolute;
			top: -1em;
			left: 0;
			width: 100%;
			cursor: pointer;
			color: #990;
		}

		details[data-cate="traits"] div {
			columns: 2;
		}
	}

	.filter-label {
		align-items: center;
	}

	#el_list {
		display: grid;
		font-size: smaller;
		grid-template-columns: repeat(14, 1fr);
		padding: .5em 1em;
		margin-bottom: max(30vh, 20em);

		@media (max-width: 1200px) {
			grid-template-columns: repeat(11, 1fr);
		}
		@media (max-width: 860px) {
			grid-template-columns: repeat(6, 1fr);

			.head,
			.item {
				& > div:first-child {
					grid-row: 1 / span 3;
				}
			}
		}
		@media (max-width: 540px) {
			grid-template-columns: repeat(4, 1fr);

			.head,
			.item {
				& > div:first-child {
					grid-row: 1 / span 3;
					grid-column: 1 / span 2;
				}

				& > div:nth-of-type(2),
				& > div:nth-of-type(3) {
					order: 1;
					margin-bottom: 2em;
					border-bottom-width: 3px;
				}

				& > div:nth-child(n + 10) {
					order: 2;
					margin-bottom: 2em;
					border-bottom-width: 3px;
				}
			}
		}
	}

	#el_list.is-grouped {
		display: block;
		width: fit-content;
		margin: 0 auto 5em;
	}

	.grouped-heros-cate {
		margin-bottom: 2em;
		width: fit-content;
	}

	.grouped-heros-box {
		display: flex;
		flex-wrap: wrap;

		body:has(#class-spliter:checked) & {
			display: grid;
			grid-auto-flow: row dense;
			/* grid-template-columns: repeat(7, 1fr); */

			.grouped-hero {
				&[data-class-mage="1"],
				&[data-class-warrior="1"],
				&[data-class-rogue="1"] {
					border-left: 1px dashed #fff3;
				}
			}
		}
	}

	.grouped-hero {
		display: block;
		text-align: center;
		font-size: smaller;
		padding: .5em;
		/* max-width: calc(64px +); */

		img {
			display: block;
		}

		div {
			opacity: 0.5;
		}

		&:hover {
			background-color: #fff1;

			div {
				opacity: 1;
			}
		}

		.grouped-hero__name {
			max-width: 64px;
		}
	}

	.head {
		position: sticky;
		top: 0;
		order: -10000000000;
		background-color: rgba(var(--bgc), .75);
		background-color: #666c;
		text-transform: uppercase;
		font-size: small;
		font-weight: 900;
		backdrop-filter: blur(1px);
	}

	.head,
	.item {
		ul:not(.is-grouped) & {
			display: grid;
			grid-column: 1 / -1;
			grid-template-columns: subgrid;

			@media (max-width: 1200px) {
				& > div:nth-child(n + 12) {
					display: none;
				}
			}

			& > div {
				/* max-width: 100px; */
				padding: 0.5em 0.25em;
				text-align: center;
				border-bottom: 1px dotted #fff3;
				border-right: 1px dotted #fff3;
				place-content: center;

				&[data-name] {
					text-align: start;
				}
			}
		}
	}

	.item .label {
		display: none;
	}

	.value {
		white-space: pre-wrap;
		place-content: center;
		text-align: center;
		line-height: 1;

		a {
			text-decoration: unset;
			display: block;
		}
	}

	.trait-box {
		display: inline-flex;
		align-items: center;
		padding: 2px .5em;
		margin: 0.2em 0;

		&:hover {
			background-color: #fff3;
		}

		&::before { content: '['; padding-inline-end: 2px; }
		&::after { content: ']'; padding-inline-start: 2px; }
	}

	div[data-affinity] .value::before {
		content: '◼ ';
		color: var(--color);
		font-size: 1.5rem;
		filter: drop-shadow(2px 4px 6px);
		text-shadow: -.5rem -.5rem;
		z-index: -1;
		position: relative;
	}
	div[data-affinity="Light"] { --color: #ff0; }
	div[data-affinity="Red"] { --color: #f00; }
	div[data-affinity="Dark"] { --color: #000; }
	div[data-affinity="Blue"] { --color: #66f; }
	div[data-affinity="Green"] { --color: #0a0; }

	.flex {
		display: flex;
	}

	body {
		margin: 0;
		background-color: rgb(var(--bgc));
		color: rgb(var(--main-color));
		overflow-y: scroll;
	}

	:root {
		--bgc: 51, 51, 51;
		--main-color: 238, 238, 238;
		color-scheme: dark;
		font-family: sans-serif;
	}

	* {
		box-sizing: border-box;
	}

	ul {
		margin: 0;
		padding: 0;
	}

	hr {
		border: 1px dashed;
		border-width: 0px;
		border-top-width: 1px;
		opacity: 0.25;
	}
	h1 {
		text-align: center;
		width: fit-content;
		padding: .25em 2vw;
		margin: 0 auto;
	}
	.el_switcher_box {
		width: fit-content;
		margin: 0 auto;

		summary {
			opacity: 0.3;
		}

		&:not([open]) {
		}

		#el_switcher {
			text-transform: capitalize;
		}
	}
</style>
</head>

<body>

	<a href="./" style="color: inherit; position: absolute">./</a>

	<h1>Hero List | Rivengard</h1>

	<details class="el_switcher_box">
		<summary>-------------------------</summary>
		<div class="flex">
			<input type="checkbox" id="class-spliter" title="separate by class">
			⋮
			<select id="el_switcher"></select>
		</div>
	</details>

	<div id="app">

		<form id="el_form">
			<details open>
				<summary class="filter-toggle">Filters</summary>
				<div>
					<!--
					<div class="flex" style="gap: .25em">
						<input type="search" name="query" id="el_query">
						<input type="reset" id="el_reset">
					</div>
					-->
					<input type="reset" id="el_reset">

					<ul id="el_filters">
					</ul>
				</div>
			</details>
			<style id="el_filter_style"></style>
		</form>

		<ul id="el_list"></ul>
	</div>

	<script src="./heros.js"></script>
	<script>
		// init
		// init
		// init

		let props = [
			'name',
			'rarity',
			'affinity',
			'class',
			'faction',
			'damage_type',
			'armor_type',
			// 'slot1',
			// 'slot2',
			// 'slot3',
			'traits',
			'slots',
			'range',
			'movement',
			'hp',
			'damage',
			'armor',
		];

		let switcher_props = [
			'rarity',
			'affinity',
			'class',
			'faction',
			'damage_type',
			'armor_type',
			'traits',
			'range',
			'movement',
		];

		let filter_props = [
			'rarity',
			'affinity',
			'class',
			'damage_type',
			'armor_type',
			'slot1',
			'slot2',
			'slot3',
			'range',
			'movement',
			'faction',
			'traits',
		];

		let filter_rendering_grounp = [
			'rarity',
			'affinity',
			'class',
			{
				title: 'type',
				items: [
					'damage_type',
					'armor_type',
				],
				open: true,
			},
			{
				title: 'grid',
				items: [
					'range',
					'movement',
				],
				open: true,
			},
			{
				title: 'slot',
				items: [
					'slot1',
					'slot2',
					'slot3',
				],
				open: false,
			},
			'faction',
			'traits',
		];

		const all_traits = {
	    "Affinity Weakness": "Enemies of opposite affinities/colors deal ×2 damage against the unit's armor and have ×2 crit and block chances against the unit.",
	    "Amphibious": "Can pass Water tiles but not end their move on them.",
	    "Bushkin": "Deals +20% attack damage when standing in Shrubs.",
	    "Burned by Light": "Takes 50% of max Health as damage at the start of each of its turns when not in Darkness, and takes ×2 damage from Light units.",
	    "Burrow": "Moves underground, ignoring obstacles and units.",
	    "Dragon Scales": "Armor completely regenerates at the beginning of its turn.",
	    "Eager": "Moves one tile towards the nearest enemy at the start of its turn, if not adjacent to an enemy.",
	    "Elemental": "Gets healed by 25% of initial health at the beginning of the turn when standing on a tile of matching affinity/color, and ignores its negative effects.",
	    "Erratic": "Targets a random enemy in range when attacking.",
	    "Fatal Landing": "Damages and displaces units when landing (units that cannot be displaced die)",
	    "Fear of Death": "Moves to an adjacent tile, trying to move as far as possible from the damage source, after taking damage.",
	    "Flying": "Can traverse impassable tiles and enemies and move between any elevation.",
	    "Healer": "Can heal a friendly unit as its action.  Heal amount is Healer's damage.",
	    "Hulking": "Cannot be displaced or devoured.  Must stop its movement immediately after going to higher elevation (relative with start position).",
	    "Immune": "Immune to all tile and unit effects",
	    "Inebriated": "Deals and receives +10% damage for each round after the first.",
	    "Life Bond": "Any damage dealt is also immediately dealt to the unit that originally summoned it",
	    "Looter": "Adds 10% Gold to the battle rewards for each enemy defeated in an adjacent tile (excluding Summons and Objects) if hero survives.",
	    "Magic Resistance": "Takes 20% less magical damage",
	    "Mechanic": "Can Repair a friendly unit as its action.  Health and Armor repaired is Mechanic's damage.",
	    "Mechanical": "Cannot be healed, but can be repaired. Repair also increases Armor by the same amount.",
	    "Mounted": "Movement not blocked by special tiles (e.g. Thorns or Broken Ice).",
	    "Night Vision": "Have no negative effects from Darkness and deal +50% damage against enemies in Darkness.",
	    "Object": "Automatically takes its action, if any at the beginning of the turn. Cannot be Healed. A player loses the battle if their only remaining units are Objects.",
	    "Polearm": "Deals 50% more damage against Mounted units.  Enemies entering an adjacent tile must stop.",
	    "Ranged": "When adjacent to an enemy, range is reduced to 1 and damage is reduced by 50%.",
	    "Shadewalker": "When starting their turn in Darkness, can move to any other Tile on the board with Darkness.",
	    "Steppable": "Can be stepped on",
	    "Sturdy": "Takes 75% less damage from ranged units' normal attack.",
	    "Summon": "Moves and attacks automatically at the beginning of its turn.",
	    "Terrifying": "Takes 40% less melee damage"
		};

		String.prototype.sanitize = function() {
			return this.replace(/[,\s\']/g, '_');
		};

		// init order number
		// const WEIGHT = 70000; // for all unicode char
		const WEIGHT = 100; // for [a-z0-9 ,.']
		heros.forEach(hero => {
			hero.order = {};
			hero.traits = hero.traits.replace('n/a', '').split(',');
			props.forEach((prop, index) => {
				let order_target = hero[prop];
				hero.order[prop] = order_target;
				if (Array.isArray(order_target)) {
					order_target = order_target[0];
				}
				if (index < 8) { // words
					hero.order[prop] = [...String(order_target || '')
						.slice(0, 3)
						.padStart(3, '0')
						.toUpperCase()
					]
					.reverse()
					.reduce(
						(sum, str, index) => sum + str.codePointAt(0) * WEIGHT ** index
						, 0
					)
				}
			});
		});


		let us = new URLSearchParams(location.search);
		let us_cate = ( switcher_props.includes(us.get('cate')) && us.get('cate') ) || '';

		if (!us_cate) {
			el_list.innerHTML = fn_gen_list();
		} else {
			el_list.classList.add('is-grouped');
			document.querySelector('.el_switcher_box').open = true;
			let heros_grouped = Object.groupBy(heros, (i) => {
				return i[us_cate];
			});
			el_list.innerHTML = fn_gen_groupby(heros_grouped);
		}

		el_filters.innerHTML = fn_gen_filterdom();
		fn_gen_switcher();

		function fn_gen_switcher() {
			el_switcher.innerHTML = `<option value="">= list view =</option>` + switcher_props.map(prop => {
				return `<option value="${prop}" ${prop === us_cate ? 'selected' : ''}>${prop}</option>`;
			}).join('');

			el_switcher.addEventListener('change', (e) => {
				let _cate = e.target.value;
				console.log(e.target.value);
				if (_cate) {
					location.href = `?cate=${_cate}`;
				} else {
					location.href = './heros.html';
				}
			});
		}

		function fn_gen_groupby(heros_grouped) {
			// console.log(22, heros_grouped);
			let _html = '';
			const each_class = ['Mage', 'Rogue', 'Warrior', ]
			let each_class_maxcount = [0, 0, 0];

			for (let cate in heros_grouped) {
				let each_class_count = [0, 0, 0];
				_html += `<div class="grouped-heros-cate">
					<h3>${cate}</h3>
					<div class="grouped-heros-box">
						${
							heros_grouped[cate].map((hero) => {
								let ci = each_class.indexOf(hero.class);
								each_class_count[ci] += 1;
								if (each_class_count[ci] > each_class_maxcount[ci]) {
									each_class_maxcount[ci] = each_class_count[ci];
								}
								return fn_gen_grouped_hero(hero, each_class_count[ci]);
							}).join('')
						}
					</div>
				</div>`;
			}

			let style = fn_gen_grouped_hero_order_style(each_class_maxcount);

			return _html + style;

			function fn_gen_grouped_hero_order_style(each_class_maxcount) {

				if (us_cate === 'class') {
					return `<style>.grouped-heros-box { display: flex; }</style>`;
				}

				const each_class = ['mage', 'rogue', 'warrior', ];
				let _style = '';
				each_class_maxcount.map((count, index) => {
					for (let i = 1; i <= count; i++) {
						let _order = (index ? fn_sumarray(each_class_maxcount.slice(0, index)) : 0) + i;
						_style += `.grouped-hero[data-class-${each_class[index]}="${i}"] { grid-column-start: ${_order};}`
					}
				});
				return `<style>${_style} .grouped-heros-box { grid-template-columns: repeat(${fn_sumarray(each_class_maxcount)}, calc(64px + 1em));}</style>`;
			}

			function fn_sumarray(array) {
				return array.reduce((all, cur) => all + cur, 0);
			}

			function fn_gen_grouped_hero(hero, index) {
				let _props = fn_gen_hero_props(hero);
				return `
					<div class="grouped-hero item" ${_props} data-class-${hero.class}="${index}">
						<a href="${hero.link}" target="_blank"><img src="./imgs/${hero.img}" width="64" height="64"></a>
						<div class=grouped-hero__name>
							${hero.name}
						</div>
					</div>
				`
			}
		}

		function fn_gen_hero_props(hero) {
			return props.map(p => {
				if (p === 'slots') {
					return ['slot1', 'slot2', 'slot3'].map(j => ` data-${j}_${hero[j]}`).join('');
				} else if (p === 'traits') {
					return hero[p]
						.map(i => ` data-${p}_${i.sanitize()}`)
						.join('');
				}
				return ` data-${p}_${(hero[p] + '').sanitize()}`;
			}).join('');
		}

		function fn_gen_list() {
			return (
				'<li id="el_head" class="head" data-dir="-1">' + props.map((p, index) => `<div data-index="${index}">
					<span class="label">${p}</span>
				</div>`).join('') + '</li><style id="el_head_style"></style>'
			) +
			heros.map(hero => {
				// let query = props.map(p => hero[p]).join();
				// let _props = props.map(p => {
				// 	if (p === 'slots') {
				// 		return ['slot1', 'slot2', 'slot3'].map(j => ` data-${j}="${hero[j]}"`).join('');
				// 	}
				// 	return ` data-${p}="${hero[p]}"`;
				// }).join('');
				let _props = fn_gen_hero_props(hero);
				let orders_style = props.map(p => `--order-${p}: ${hero.order[p]};`).join(' ');
				return (
					`<li class="item" ${_props} style="${orders_style}">`
					+ props.map(p => fn_gen_td(hero, p)).join('')
					+ '</li>'
				);
			}).join('');

			function fn_gen_td(hero, p) {
				let ctx = hero[p];

				if (p === 'name') {
					ctx = `<a href="${hero.link}" target="_blank"><img src="./imgs/${hero.img}" width="64" height="64"><br/></a>${hero[p]}`;
				} else if (p === 'slots') {
					ctx = [hero.slot1, hero.slot2, hero.slot3].join('\n');
					return `<div data-slot1="${hero.slot1}" data-slot2="${hero.slot2}" data-slot3="${hero.slot3}">
						<div class="label">${p}:</div>
						<div class="value">${ctx}</div>
					</div>`;
				// 	ctx = [hero.slot1, hero.slot2, hero.slot3].join('\n');
				// 	console.log(ctx);
				// 	return
				// 		`<div>
				// 			<div class="label">${p}:</div>
				// 			<div class="value">123</div>
				// 		</div>`
				// 	// ctx = hero[p].map(i => `<span class="trait-box" title="${all_traits[i] || ''}">${i}</span>`).join('<br>');
				} else if (p === 'traits') {
					ctx = hero[p].map(i => `<span class="trait-box" title="${all_traits[i] || ''}">${i}</span>`).join('<br>');
				}

				return (
					`<div data-${p}="${hero[p]}">
							<div class="label">${p}:</div>
							<div class="value">${ctx}</div>
						</div>`
				);
			}
		}

		function fn_gen_filterdom(argument) {
			let filter_html = ``;

			let filter_cates = heros.reduce((all, hero) => {
				filter_props.forEach(prop => {
					if (!all[prop]) {
						all[prop] = [];
					}
					all[prop].push(hero[prop]);
				});
				return all;
			}, {});

			for (let cate in filter_cates) {
				if (cate === 'traits') {
					filter_cates[cate] = [...new Set(filter_cates[cate].flat())].sort();
				} else {
					filter_cates[cate] = [...new Set(filter_cates[cate])].sort();
				}
			}
			console.log(123, filter_cates);

			function fn_gen_checkboxs(cate) {
				let dd = filter_cates[cate].map(i => `
					<dd>
						<label class="filter-label flex">
							<input type="checkbox" name="${cate}" value="${(i + '').sanitize()}" id="filter-${cate}_${i}">
							${i}
						</label>
					</dd>
				`).join('');

				return `<fieldset>
					<legend>${cate}</legend>
					<details data-cate="${cate}" ${filter_cates[cate].length < 6 ? 'open' : ''}>
						<summary></summary>
						<div>
							${dd}
						</div>
					</details>
				</fieldset>`;
			}

			for (let group of filter_rendering_grounp) {
				if (typeof group === 'string') {
					filter_html += fn_gen_checkboxs(group)
				} else if (group.items) {
					filter_html += `<fieldset>
						<legend>${group.title}</legend>
						<details ${group.open ? 'open' : ''}>
							<summary></summary>
							<div>
								${group.items.map(fn_gen_checkboxs).join('')}
							</div>
						</details>
					</fieldset>`
				}
			}

			el_form.querySelector(':scope > details').open = !us_cate;

			return filter_html;
		}

		// binding:
		// binding:
		// binding:

		window.el_form.addEventListener('input', fn_form_update);
		window.el_form.addEventListener('reset', fn_update_style);
		window.el_head?.addEventListener('click', fn_reorder_table);

		function fn_form_update() {
			let formData = new FormData(el_form);

			if (![...formData.entries()].length) {
				fn_update_style();
				return;
			}

			let pairs = {};
			for (const [key, value] of formData.entries()) {
				if (pairs.hasOwnProperty(key)) {
			    pairs[key].push(value);
				} else {
				  pairs[key] = [value];
				}
			}

			let selectors = [];
			for (let prop in pairs) {
				selectors.push(
					`.item.item:not(`+ pairs[prop].map(v => `[data-${prop}_${v}]`).join(',') +`)`
				)
			}

			let _style = selectors.join(',') + `{ display: none; }`;

			fn_update_style(_style);
		}

		function fn_update_style(style = '') {
			el_filter_style.innerHTML = style || '';
		}

		function fn_reorder_table(e) {
			let dir = +(el_head.dataset.dir) || 1;
			let index = e.target.closest('div')?.dataset.index;
			if (!index) {
				el_head_style.innerHTML = '';
				return;
			}
			index = +index;
			el_head.dataset.dir = dir * -1;

			el_head_style.innerHTML = `li.item { order: calc(var(--order-${props[index]}, 0) * ${dir * -1}); }`;
		}

	</script>
</body>
</html>